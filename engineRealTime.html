<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dino Game - Treinamento em Tempo Real</title>
  <style>
    canvas {
      border: 1px solid black;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Dino Game - Treinamento em Tempo Real</h1>
  <canvas id="gameCanvas" width="600" height="150"></canvas>
  <p>Os quadrados representam diferentes indivíduos sendo treinados em tempo real.</p>

  <script>
    class GameEngine {
      constructor(id, color, thickness) {
        this.id = id; // Identificador do indivíduo
        this.color = color; // Cor do indivíduo
        this.thickness = thickness; // Espessura do traçado (opcional)
        this.reset();
      }

      reset() {
        this.tRex = {
          xPos: 50,
          yPos: 0,
          jumping: false,
          ducking: false,
          velocityY: 0,
          width: 44,
          height: 47,
          collisionBoxes: [
            { x: 1, y: 1, width: 30, height: 35 },
            { x: 5, y: 35, width: 20, height: 10 },
          ],
        };

        this.obstacles = [];
        this.score = 0;
        this.gameOver = false;
        this.currentSpeed = 6;
        this.maxSpeed = 13;
        this.acceleration = 0.001;
        this.gravity = -0.6;
        this.jumpVelocity = 12;
        this.groundYPos = 0;
        this.time = Date.now();
        this.deltaTime = 0;
        this.distanceRan = 0;
        this.scoreCoefficient = 0.025;
        this.msPerFrame = 1000 / 60;
        this.nextObstacleDistance = null;
        this.dimensions = {
          WIDTH: 600,
          HEIGHT: 150,
        };
      }

      update(action) {
        if (this.gameOver) return;

        const now = Date.now();
        this.deltaTime = now - (this.time || now);
        this.time = now;

        this.handleAction(action);
        this.updateTRex();
        this.updateObstacles();

        if (this.checkCollision()) {
          this.gameOver = true;
        } else {
          this.distanceRan += (this.currentSpeed * this.deltaTime) / this.msPerFrame;
          this.score = Math.floor(this.distanceRan * this.scoreCoefficient);

          if (this.currentSpeed < this.maxSpeed) {
            this.currentSpeed += this.acceleration * (this.deltaTime / this.msPerFrame);
          }
        }
      }

      handleAction(action) {
        if (action === 0 && !this.tRex.jumping && !this.tRex.ducking) {
          this.tRex.jumping = true;
          this.tRex.velocityY = this.jumpVelocity;
        } else if (action === 1 && !this.tRex.jumping) {
          this.tRex.ducking = true;
          this.tRex.height = 25;
          this.tRex.width = 59;
        } else if (action === 2) {
          if (this.tRex.ducking) {
            this.tRex.ducking = false;
            this.tRex.height = 47;
            this.tRex.width = 44;
          }
        }
      }

      updateTRex() {
        if (this.tRex.jumping) {
          this.tRex.velocityY += this.gravity;
          this.tRex.yPos += this.tRex.velocityY;

          if (this.tRex.yPos <= 0) {
            this.tRex.yPos = 0;
            this.tRex.jumping = false;
            this.tRex.velocityY = 0;
          }
        }
      }

      updateObstacles() {
        this.obstacles.forEach((obstacle) => {
          obstacle.xPos -= this.currentSpeed * (this.deltaTime / this.msPerFrame);
        });

        this.obstacles = this.obstacles.filter(
          (obstacle) => obstacle.xPos + obstacle.width > 0
        );

        if (this.shouldAddNewObstacle()) {
          this.addNewObstacle();
        }
      }

      shouldAddNewObstacle() {
        if (this.obstacles.length === 0) return true;

        const lastObstacle = this.obstacles[this.obstacles.length - 1];

        if (!this.nextObstacleDistance) {
          const minGap = (100 + this.currentSpeed * 10) * 1.2;
          const maxGap = (200 + this.currentSpeed * 14) * 1.2;
          this.nextObstacleDistance =
            Math.floor(Math.random() * (maxGap - minGap + 1)) + minGap;
        }

        return (
          lastObstacle.xPos + lastObstacle.width <
          this.dimensions.WIDTH - this.nextObstacleDistance
        );
      }

      addNewObstacle() {
        const obstacleTypes = this.score >= 300 ? [
          // Variantes de cactos e pássaros após 300 pontos
          { width: 30, height: 35, yPos: 0 },
          { width: 40, height: 35, yPos: 0 },
          { width: 50, height: 35, yPos: 0 },
          { width: 70, height: 35, yPos: 0 },
          { width: 25, height: 45, yPos: 0 },
          { width: 45, height: 45, yPos: 0 },
          { width: 75, height: 45, yPos: 0 },
          { width: 30, height: 25, yPos: 30 }, // Pássaro voador baixo
          { width: 30, height: 25, yPos: 80 }, // Pássaro voador alto
        ] : [
          // Cactos antes dos 300 pontos
          { width: 30, height: 35, yPos: 0 },
          { width: 40, height: 35, yPos: 0 },
          { width: 50, height: 35, yPos: 0 },
          { width: 70, height: 35, yPos: 0 },
          { width: 25, height: 45, yPos: 0 },
          { width: 45, height: 45, yPos: 0 },
          { width: 75, height: 45, yPos: 0 },
        ];

        const obstacleType =
          obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];

        const obstacle = {
          xPos: this.dimensions.WIDTH,
          yPos: obstacleType.yPos,
          width: obstacleType.width,
          height: obstacleType.height,
          collisionBoxes: [{ x: 0, y: 0, width: obstacleType.width, height: obstacleType.height }],
        };

        this.obstacles.push(obstacle);
        this.nextObstacleDistance = null;
      }

      checkCollision() {
        for (let obstacle of this.obstacles) {
          if (this.isColliding(this.tRex, obstacle)) {
            return true;
          }
        }
        return false;
      }

      isColliding(tRex, obstacle) {
        for (let tRexBox of tRex.collisionBoxes) {
          const adjTrexBox = {
            x: tRex.xPos + tRexBox.x,
            y: this.dimensions.HEIGHT - tRex.height - tRex.yPos + tRexBox.y,
            width: tRexBox.width,
            height: tRexBox.height,
          };

          for (let obstacleBox of obstacle.collisionBoxes) {
            const adjObstacleBox = {
              x: obstacle.xPos + obstacleBox.x,
              y: this.dimensions.HEIGHT - obstacle.height - obstacle.yPos + obstacleBox.y,
              width: obstacleBox.width,
              height: obstacleBox.height,
            };

            if (this.boxCompare(adjTrexBox, adjObstacleBox)) {
              return true;
            }
          }
        }
        return false;
      }

      boxCompare(boxA, boxB) {
        return !(
          boxA.x > boxB.x + boxB.width ||
          boxA.x + boxA.width < boxB.x ||
          boxA.y > boxB.y + boxB.height ||
          boxA.y + boxA.height < boxB.y
        );
      }

      getState() {
        return {
          tRex: this.tRex,
          obstacles: this.obstacles.map((obstacle) => ({
            xPos: obstacle.xPos,
            yPos: obstacle.yPos,
            width: obstacle.width,
            height: obstacle.height,
          })),
          score: this.score,
          gameOver: this.gameOver,
          id: this.id,
          color: this.color,
          thickness: this.thickness,
        };
      }
    }

    // Configurações para múltiplos indivíduos
    const numIndividuals = 5; // Número de indivíduos a serem exibidos
    const individuals = [];

    // Gerar cores e espessuras aleatórias
    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    function getRandomThickness() {
      return Math.floor(Math.random() * 3) + 1; // Espessura entre 1 e 3
    }

    // Inicializar os indivíduos
    for (let i = 0; i < numIndividuals; i++) {
      const color = getRandomColor();
      const thickness = getRandomThickness();
      const gameEngine = new GameEngine(i, color, thickness);
      individuals.push(gameEngine);
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Obstáculos compartilhados entre os indivíduos
    let sharedObstacles = [];

    function drawTRex(tRex, color, thickness) {
      ctx.fillStyle = color;
      ctx.fillRect(tRex.xPos, canvas.height - tRex.height - tRex.yPos, tRex.width, tRex.height);
    }

    function drawObstacles(obstacles) {
      ctx.fillStyle = 'red';
      obstacles.forEach(obstacle => {
        ctx.fillRect(obstacle.xPos, canvas.height - obstacle.height - obstacle.yPos, obstacle.width, obstacle.height);
      });
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function renderGame(gameStates) {
      clearCanvas();
      // Desenhar obstáculos uma vez
      drawObstacles(sharedObstacles);

      // Desenhar cada indivíduo
      gameStates.forEach(state => {
        ctx.lineWidth = state.thickness;
        drawTRex(state.tRex, state.color, state.thickness);
      });

      // Desenhar o score do primeiro indivíduo
      ctx.fillStyle = 'black';
      ctx.font = '20px Arial';
      ctx.fillText(`Score: ${gameStates[0].score}`, 500, 20);
    }

    let action = 2; // Nenhuma ação por padrão

    function gameLoop() {
      // Atualizar obstáculos compartilhados
      updateSharedObstacles();

      const gameStates = [];
      individuals.forEach(gameEngine => {
        if (!gameEngine.gameOver) {
          const action = chooseAction(gameEngine.getState());
          gameEngine.update(action);
          gameEngine.obstacles = sharedObstacles; // Sincronizar obstáculos
        }
        gameStates.push(gameEngine.getState());
      });

      renderGame(gameStates);

      if (individuals.some(ge => !ge.gameOver)) {
        requestAnimationFrame(gameLoop);
      } else {
        alert('Treinamento concluído! Todos os indivíduos terminaram.');
      }
    }

    // Função para atualizar obstáculos compartilhados
    function updateSharedObstacles() {
      // Atualizar obstáculos
      sharedObstacles.forEach((obstacle) => {
        obstacle.xPos -= individuals[0].currentSpeed * (individuals[0].deltaTime / individuals[0].msPerFrame);
      });

      // Remover obstáculos que saíram da tela
      sharedObstacles = sharedObstacles.filter(
        (obstacle) => obstacle.xPos + obstacle.width > 0
      );

      // Adicionar novos obstáculos se necessário
      if (shouldAddNewObstacle()) {
        addNewObstacle();
      }
    }

    function shouldAddNewObstacle() {
      if (sharedObstacles.length === 0) return true;

      const lastObstacle = sharedObstacles[sharedObstacles.length - 1];

      if (!individuals[0].nextObstacleDistance) {
        const minGap = (100 + individuals[0].currentSpeed * 10) * 1.2;
        const maxGap = (200 + individuals[0].currentSpeed * 14) * 1.2;
        individuals[0].nextObstacleDistance =
          Math.floor(Math.random() * (maxGap - minGap + 1)) + minGap;
      }

      return (
        lastObstacle.xPos + lastObstacle.width <
        individuals[0].dimensions.WIDTH - individuals[0].nextObstacleDistance
      );
    }

    function addNewObstacle() {
      const obstacleTypes = individuals[0].score >= 300 ? [
        { width: 30, height: 35, yPos: 0 },
        { width: 40, height: 35, yPos: 0 },
        { width: 50, height: 35, yPos: 0 },
        { width: 70, height: 35, yPos: 0 },
        { width: 25, height: 45, yPos: 0 },
        { width: 45, height: 45, yPos: 0 },
        { width: 75, height: 45, yPos: 0 },
        { width: 30, height: 25, yPos: 30 },
        { width: 30, height: 25, yPos: 80 },
      ] : [
        { width: 30, height: 35, yPos: 0 },
        { width: 40, height: 35, yPos: 0 },
        { width: 50, height: 35, yPos: 0 },
        { width: 70, height: 35, yPos: 0 },
        { width: 25, height: 45, yPos: 0 },
        { width: 45, height: 45, yPos: 0 },
        { width: 75, height: 45, yPos: 0 },
      ];

      const obstacleType =
        obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];

      const obstacle = {
        xPos: individuals[0].dimensions.WIDTH,
        yPos: obstacleType.yPos,
        width: obstacleType.width,
        height: obstacleType.height,
        collisionBoxes: [{ x: 0, y: 0, width: obstacleType.width, height: obstacleType.height }],
      };

      sharedObstacles.push(obstacle);
      individuals.forEach(ge => {
        ge.nextObstacleDistance = null;
      });
    }

    // Função para decidir a ação do indivíduo (simulação de treinamento)
    function chooseAction(state) {
      // Aqui você pode implementar sua lógica de decisão ou usar um modelo treinado
      // Para demonstração, vamos usar ações aleatórias
      return Math.floor(Math.random() * 3); // 0: pular, 1: abaixar, 2: nada
    }

    gameLoop();
  </script>
</body>
</html>
